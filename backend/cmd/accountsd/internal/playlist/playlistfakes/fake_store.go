// Code generated by counterfeiter. DO NOT EDIT.
package playlistfakes

import (
	"context"
	"sync"

	"github.com/JordanRad/play-j/backend/cmd/accountsd/internal/db/dbmodels"
	"github.com/JordanRad/play-j/backend/cmd/accountsd/internal/playlist"
)

type FakeStore struct {
	CreateAccountPlaylistStub        func(context.Context, uint, string) (bool, error)
	createAccountPlaylistMutex       sync.RWMutex
	createAccountPlaylistArgsForCall []struct {
		arg1 context.Context
		arg2 uint
		arg3 string
	}
	createAccountPlaylistReturns struct {
		result1 bool
		result2 error
	}
	createAccountPlaylistReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	DeleteAccountPlaylistStub        func(context.Context, uint, uint) (bool, error)
	deleteAccountPlaylistMutex       sync.RWMutex
	deleteAccountPlaylistArgsForCall []struct {
		arg1 context.Context
		arg2 uint
		arg3 uint
	}
	deleteAccountPlaylistReturns struct {
		result1 bool
		result2 error
	}
	deleteAccountPlaylistReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	GetAccountPlaylistStub        func(context.Context, uint, uint) (*dbmodels.Playlist, error)
	getAccountPlaylistMutex       sync.RWMutex
	getAccountPlaylistArgsForCall []struct {
		arg1 context.Context
		arg2 uint
		arg3 uint
	}
	getAccountPlaylistReturns struct {
		result1 *dbmodels.Playlist
		result2 error
	}
	getAccountPlaylistReturnsOnCall map[int]struct {
		result1 *dbmodels.Playlist
		result2 error
	}
	GetAllAccountPlaylistsStub        func(context.Context, uint) ([]*dbmodels.Playlist, error)
	getAllAccountPlaylistsMutex       sync.RWMutex
	getAllAccountPlaylistsArgsForCall []struct {
		arg1 context.Context
		arg2 uint
	}
	getAllAccountPlaylistsReturns struct {
		result1 []*dbmodels.Playlist
		result2 error
	}
	getAllAccountPlaylistsReturnsOnCall map[int]struct {
		result1 []*dbmodels.Playlist
		result2 error
	}
	UpdateAccountPlaylistNameStub        func(context.Context, uint, string) (bool, error)
	updateAccountPlaylistNameMutex       sync.RWMutex
	updateAccountPlaylistNameArgsForCall []struct {
		arg1 context.Context
		arg2 uint
		arg3 string
	}
	updateAccountPlaylistNameReturns struct {
		result1 bool
		result2 error
	}
	updateAccountPlaylistNameReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	UpdateAccountPlaylistTracksStub        func(context.Context, uint, uint, string) (bool, error)
	updateAccountPlaylistTracksMutex       sync.RWMutex
	updateAccountPlaylistTracksArgsForCall []struct {
		arg1 context.Context
		arg2 uint
		arg3 uint
		arg4 string
	}
	updateAccountPlaylistTracksReturns struct {
		result1 bool
		result2 error
	}
	updateAccountPlaylistTracksReturnsOnCall map[int]struct {
		result1 bool
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeStore) CreateAccountPlaylist(arg1 context.Context, arg2 uint, arg3 string) (bool, error) {
	fake.createAccountPlaylistMutex.Lock()
	ret, specificReturn := fake.createAccountPlaylistReturnsOnCall[len(fake.createAccountPlaylistArgsForCall)]
	fake.createAccountPlaylistArgsForCall = append(fake.createAccountPlaylistArgsForCall, struct {
		arg1 context.Context
		arg2 uint
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.CreateAccountPlaylistStub
	fakeReturns := fake.createAccountPlaylistReturns
	fake.recordInvocation("CreateAccountPlaylist", []interface{}{arg1, arg2, arg3})
	fake.createAccountPlaylistMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStore) CreateAccountPlaylistCallCount() int {
	fake.createAccountPlaylistMutex.RLock()
	defer fake.createAccountPlaylistMutex.RUnlock()
	return len(fake.createAccountPlaylistArgsForCall)
}

func (fake *FakeStore) CreateAccountPlaylistCalls(stub func(context.Context, uint, string) (bool, error)) {
	fake.createAccountPlaylistMutex.Lock()
	defer fake.createAccountPlaylistMutex.Unlock()
	fake.CreateAccountPlaylistStub = stub
}

func (fake *FakeStore) CreateAccountPlaylistArgsForCall(i int) (context.Context, uint, string) {
	fake.createAccountPlaylistMutex.RLock()
	defer fake.createAccountPlaylistMutex.RUnlock()
	argsForCall := fake.createAccountPlaylistArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStore) CreateAccountPlaylistReturns(result1 bool, result2 error) {
	fake.createAccountPlaylistMutex.Lock()
	defer fake.createAccountPlaylistMutex.Unlock()
	fake.CreateAccountPlaylistStub = nil
	fake.createAccountPlaylistReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) CreateAccountPlaylistReturnsOnCall(i int, result1 bool, result2 error) {
	fake.createAccountPlaylistMutex.Lock()
	defer fake.createAccountPlaylistMutex.Unlock()
	fake.CreateAccountPlaylistStub = nil
	if fake.createAccountPlaylistReturnsOnCall == nil {
		fake.createAccountPlaylistReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.createAccountPlaylistReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) DeleteAccountPlaylist(arg1 context.Context, arg2 uint, arg3 uint) (bool, error) {
	fake.deleteAccountPlaylistMutex.Lock()
	ret, specificReturn := fake.deleteAccountPlaylistReturnsOnCall[len(fake.deleteAccountPlaylistArgsForCall)]
	fake.deleteAccountPlaylistArgsForCall = append(fake.deleteAccountPlaylistArgsForCall, struct {
		arg1 context.Context
		arg2 uint
		arg3 uint
	}{arg1, arg2, arg3})
	stub := fake.DeleteAccountPlaylistStub
	fakeReturns := fake.deleteAccountPlaylistReturns
	fake.recordInvocation("DeleteAccountPlaylist", []interface{}{arg1, arg2, arg3})
	fake.deleteAccountPlaylistMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStore) DeleteAccountPlaylistCallCount() int {
	fake.deleteAccountPlaylistMutex.RLock()
	defer fake.deleteAccountPlaylistMutex.RUnlock()
	return len(fake.deleteAccountPlaylistArgsForCall)
}

func (fake *FakeStore) DeleteAccountPlaylistCalls(stub func(context.Context, uint, uint) (bool, error)) {
	fake.deleteAccountPlaylistMutex.Lock()
	defer fake.deleteAccountPlaylistMutex.Unlock()
	fake.DeleteAccountPlaylistStub = stub
}

func (fake *FakeStore) DeleteAccountPlaylistArgsForCall(i int) (context.Context, uint, uint) {
	fake.deleteAccountPlaylistMutex.RLock()
	defer fake.deleteAccountPlaylistMutex.RUnlock()
	argsForCall := fake.deleteAccountPlaylistArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStore) DeleteAccountPlaylistReturns(result1 bool, result2 error) {
	fake.deleteAccountPlaylistMutex.Lock()
	defer fake.deleteAccountPlaylistMutex.Unlock()
	fake.DeleteAccountPlaylistStub = nil
	fake.deleteAccountPlaylistReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) DeleteAccountPlaylistReturnsOnCall(i int, result1 bool, result2 error) {
	fake.deleteAccountPlaylistMutex.Lock()
	defer fake.deleteAccountPlaylistMutex.Unlock()
	fake.DeleteAccountPlaylistStub = nil
	if fake.deleteAccountPlaylistReturnsOnCall == nil {
		fake.deleteAccountPlaylistReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.deleteAccountPlaylistReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) GetAccountPlaylist(arg1 context.Context, arg2 uint, arg3 uint) (*dbmodels.Playlist, error) {
	fake.getAccountPlaylistMutex.Lock()
	ret, specificReturn := fake.getAccountPlaylistReturnsOnCall[len(fake.getAccountPlaylistArgsForCall)]
	fake.getAccountPlaylistArgsForCall = append(fake.getAccountPlaylistArgsForCall, struct {
		arg1 context.Context
		arg2 uint
		arg3 uint
	}{arg1, arg2, arg3})
	stub := fake.GetAccountPlaylistStub
	fakeReturns := fake.getAccountPlaylistReturns
	fake.recordInvocation("GetAccountPlaylist", []interface{}{arg1, arg2, arg3})
	fake.getAccountPlaylistMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStore) GetAccountPlaylistCallCount() int {
	fake.getAccountPlaylistMutex.RLock()
	defer fake.getAccountPlaylistMutex.RUnlock()
	return len(fake.getAccountPlaylistArgsForCall)
}

func (fake *FakeStore) GetAccountPlaylistCalls(stub func(context.Context, uint, uint) (*dbmodels.Playlist, error)) {
	fake.getAccountPlaylistMutex.Lock()
	defer fake.getAccountPlaylistMutex.Unlock()
	fake.GetAccountPlaylistStub = stub
}

func (fake *FakeStore) GetAccountPlaylistArgsForCall(i int) (context.Context, uint, uint) {
	fake.getAccountPlaylistMutex.RLock()
	defer fake.getAccountPlaylistMutex.RUnlock()
	argsForCall := fake.getAccountPlaylistArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStore) GetAccountPlaylistReturns(result1 *dbmodels.Playlist, result2 error) {
	fake.getAccountPlaylistMutex.Lock()
	defer fake.getAccountPlaylistMutex.Unlock()
	fake.GetAccountPlaylistStub = nil
	fake.getAccountPlaylistReturns = struct {
		result1 *dbmodels.Playlist
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) GetAccountPlaylistReturnsOnCall(i int, result1 *dbmodels.Playlist, result2 error) {
	fake.getAccountPlaylistMutex.Lock()
	defer fake.getAccountPlaylistMutex.Unlock()
	fake.GetAccountPlaylistStub = nil
	if fake.getAccountPlaylistReturnsOnCall == nil {
		fake.getAccountPlaylistReturnsOnCall = make(map[int]struct {
			result1 *dbmodels.Playlist
			result2 error
		})
	}
	fake.getAccountPlaylistReturnsOnCall[i] = struct {
		result1 *dbmodels.Playlist
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) GetAllAccountPlaylists(arg1 context.Context, arg2 uint) ([]*dbmodels.Playlist, error) {
	fake.getAllAccountPlaylistsMutex.Lock()
	ret, specificReturn := fake.getAllAccountPlaylistsReturnsOnCall[len(fake.getAllAccountPlaylistsArgsForCall)]
	fake.getAllAccountPlaylistsArgsForCall = append(fake.getAllAccountPlaylistsArgsForCall, struct {
		arg1 context.Context
		arg2 uint
	}{arg1, arg2})
	stub := fake.GetAllAccountPlaylistsStub
	fakeReturns := fake.getAllAccountPlaylistsReturns
	fake.recordInvocation("GetAllAccountPlaylists", []interface{}{arg1, arg2})
	fake.getAllAccountPlaylistsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStore) GetAllAccountPlaylistsCallCount() int {
	fake.getAllAccountPlaylistsMutex.RLock()
	defer fake.getAllAccountPlaylistsMutex.RUnlock()
	return len(fake.getAllAccountPlaylistsArgsForCall)
}

func (fake *FakeStore) GetAllAccountPlaylistsCalls(stub func(context.Context, uint) ([]*dbmodels.Playlist, error)) {
	fake.getAllAccountPlaylistsMutex.Lock()
	defer fake.getAllAccountPlaylistsMutex.Unlock()
	fake.GetAllAccountPlaylistsStub = stub
}

func (fake *FakeStore) GetAllAccountPlaylistsArgsForCall(i int) (context.Context, uint) {
	fake.getAllAccountPlaylistsMutex.RLock()
	defer fake.getAllAccountPlaylistsMutex.RUnlock()
	argsForCall := fake.getAllAccountPlaylistsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeStore) GetAllAccountPlaylistsReturns(result1 []*dbmodels.Playlist, result2 error) {
	fake.getAllAccountPlaylistsMutex.Lock()
	defer fake.getAllAccountPlaylistsMutex.Unlock()
	fake.GetAllAccountPlaylistsStub = nil
	fake.getAllAccountPlaylistsReturns = struct {
		result1 []*dbmodels.Playlist
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) GetAllAccountPlaylistsReturnsOnCall(i int, result1 []*dbmodels.Playlist, result2 error) {
	fake.getAllAccountPlaylistsMutex.Lock()
	defer fake.getAllAccountPlaylistsMutex.Unlock()
	fake.GetAllAccountPlaylistsStub = nil
	if fake.getAllAccountPlaylistsReturnsOnCall == nil {
		fake.getAllAccountPlaylistsReturnsOnCall = make(map[int]struct {
			result1 []*dbmodels.Playlist
			result2 error
		})
	}
	fake.getAllAccountPlaylistsReturnsOnCall[i] = struct {
		result1 []*dbmodels.Playlist
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) UpdateAccountPlaylistName(arg1 context.Context, arg2 uint, arg3 string) (bool, error) {
	fake.updateAccountPlaylistNameMutex.Lock()
	ret, specificReturn := fake.updateAccountPlaylistNameReturnsOnCall[len(fake.updateAccountPlaylistNameArgsForCall)]
	fake.updateAccountPlaylistNameArgsForCall = append(fake.updateAccountPlaylistNameArgsForCall, struct {
		arg1 context.Context
		arg2 uint
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.UpdateAccountPlaylistNameStub
	fakeReturns := fake.updateAccountPlaylistNameReturns
	fake.recordInvocation("UpdateAccountPlaylistName", []interface{}{arg1, arg2, arg3})
	fake.updateAccountPlaylistNameMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStore) UpdateAccountPlaylistNameCallCount() int {
	fake.updateAccountPlaylistNameMutex.RLock()
	defer fake.updateAccountPlaylistNameMutex.RUnlock()
	return len(fake.updateAccountPlaylistNameArgsForCall)
}

func (fake *FakeStore) UpdateAccountPlaylistNameCalls(stub func(context.Context, uint, string) (bool, error)) {
	fake.updateAccountPlaylistNameMutex.Lock()
	defer fake.updateAccountPlaylistNameMutex.Unlock()
	fake.UpdateAccountPlaylistNameStub = stub
}

func (fake *FakeStore) UpdateAccountPlaylistNameArgsForCall(i int) (context.Context, uint, string) {
	fake.updateAccountPlaylistNameMutex.RLock()
	defer fake.updateAccountPlaylistNameMutex.RUnlock()
	argsForCall := fake.updateAccountPlaylistNameArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeStore) UpdateAccountPlaylistNameReturns(result1 bool, result2 error) {
	fake.updateAccountPlaylistNameMutex.Lock()
	defer fake.updateAccountPlaylistNameMutex.Unlock()
	fake.UpdateAccountPlaylistNameStub = nil
	fake.updateAccountPlaylistNameReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) UpdateAccountPlaylistNameReturnsOnCall(i int, result1 bool, result2 error) {
	fake.updateAccountPlaylistNameMutex.Lock()
	defer fake.updateAccountPlaylistNameMutex.Unlock()
	fake.UpdateAccountPlaylistNameStub = nil
	if fake.updateAccountPlaylistNameReturnsOnCall == nil {
		fake.updateAccountPlaylistNameReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.updateAccountPlaylistNameReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) UpdateAccountPlaylistTracks(arg1 context.Context, arg2 uint, arg3 uint, arg4 string) (bool, error) {
	fake.updateAccountPlaylistTracksMutex.Lock()
	ret, specificReturn := fake.updateAccountPlaylistTracksReturnsOnCall[len(fake.updateAccountPlaylistTracksArgsForCall)]
	fake.updateAccountPlaylistTracksArgsForCall = append(fake.updateAccountPlaylistTracksArgsForCall, struct {
		arg1 context.Context
		arg2 uint
		arg3 uint
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.UpdateAccountPlaylistTracksStub
	fakeReturns := fake.updateAccountPlaylistTracksReturns
	fake.recordInvocation("UpdateAccountPlaylistTracks", []interface{}{arg1, arg2, arg3, arg4})
	fake.updateAccountPlaylistTracksMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeStore) UpdateAccountPlaylistTracksCallCount() int {
	fake.updateAccountPlaylistTracksMutex.RLock()
	defer fake.updateAccountPlaylistTracksMutex.RUnlock()
	return len(fake.updateAccountPlaylistTracksArgsForCall)
}

func (fake *FakeStore) UpdateAccountPlaylistTracksCalls(stub func(context.Context, uint, uint, string) (bool, error)) {
	fake.updateAccountPlaylistTracksMutex.Lock()
	defer fake.updateAccountPlaylistTracksMutex.Unlock()
	fake.UpdateAccountPlaylistTracksStub = stub
}

func (fake *FakeStore) UpdateAccountPlaylistTracksArgsForCall(i int) (context.Context, uint, uint, string) {
	fake.updateAccountPlaylistTracksMutex.RLock()
	defer fake.updateAccountPlaylistTracksMutex.RUnlock()
	argsForCall := fake.updateAccountPlaylistTracksArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeStore) UpdateAccountPlaylistTracksReturns(result1 bool, result2 error) {
	fake.updateAccountPlaylistTracksMutex.Lock()
	defer fake.updateAccountPlaylistTracksMutex.Unlock()
	fake.UpdateAccountPlaylistTracksStub = nil
	fake.updateAccountPlaylistTracksReturns = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) UpdateAccountPlaylistTracksReturnsOnCall(i int, result1 bool, result2 error) {
	fake.updateAccountPlaylistTracksMutex.Lock()
	defer fake.updateAccountPlaylistTracksMutex.Unlock()
	fake.UpdateAccountPlaylistTracksStub = nil
	if fake.updateAccountPlaylistTracksReturnsOnCall == nil {
		fake.updateAccountPlaylistTracksReturnsOnCall = make(map[int]struct {
			result1 bool
			result2 error
		})
	}
	fake.updateAccountPlaylistTracksReturnsOnCall[i] = struct {
		result1 bool
		result2 error
	}{result1, result2}
}

func (fake *FakeStore) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createAccountPlaylistMutex.RLock()
	defer fake.createAccountPlaylistMutex.RUnlock()
	fake.deleteAccountPlaylistMutex.RLock()
	defer fake.deleteAccountPlaylistMutex.RUnlock()
	fake.getAccountPlaylistMutex.RLock()
	defer fake.getAccountPlaylistMutex.RUnlock()
	fake.getAllAccountPlaylistsMutex.RLock()
	defer fake.getAllAccountPlaylistsMutex.RUnlock()
	fake.updateAccountPlaylistNameMutex.RLock()
	defer fake.updateAccountPlaylistNameMutex.RUnlock()
	fake.updateAccountPlaylistTracksMutex.RLock()
	defer fake.updateAccountPlaylistTracksMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeStore) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ playlist.Store = new(FakeStore)
